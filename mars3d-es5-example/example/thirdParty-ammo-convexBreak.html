<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0,minimum-scale=1.0,maximum-scale=1.0" />
    <meta name="author" content="火星科技 http://mars3d.cn " />
    <meta name="apple-touch-fullscreen" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="x5-fullscreen" content="true" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
    <!-- 标题及搜索关键字 -->
    <meta name="keywords" content="火星科技,cesium,3D,GIS,marsgis,三维,地球,地图,开发,框架,系统,示例,资料,模型,离线,外包,合肥,安徽,中国" />
    <meta
      name="description"
      content="火星科技 合肥火星 合肥火星科技 合肥火星科技有限公司 leaflet leaflet框架 leaflet开发 cesium cesium开发 cesium框架 三维 地球 模型  gis marsgis 地图离线 地图开发 地图框架 地图外包 框架 开发 外包  地图离线 二维地图 三维地图 全景漫游 地理信息系统 云GIS 三维GIS GIS平台 WebGIS"
    />

    <link rel="shortcut icon" type="image/x-icon" href="https://muyao1987.gitee.io/cdn/marsgis.cn/favicon/favicon.ico" />
    <title>ammo物理引擎扩展支持  | Mars3D | 三维地图 | 火星科技 | 合肥火星科技有限公司</title>

    <script
      type="text/javascript"
      src="../lib/include-lib.js"
      libpath="../lib/"
      include="jquery,font-awesome,bootstrap,layer,haoutil,mars3d,cesium-meshVisualizer"
    ></script>

    <link href="css/style.css" rel="stylesheet" />
  </head>

  <body class="dark">
    <div id="mars3dContainer" class="mars3d-container"></div>

    <!-- 面板 -->
    <div class="infoview">操作提示：鼠标左键单击进行发射</div>



    <script src="../lib/ammo/ex/ConvexObjectBreaker.js"></script>
    <script src="../lib/ammo/ex/QuickHull.js"></script>
    <script src="../lib/ammo/ex/geometries/ConvexGeometry.js"></script>

    <script src="./js/common.js"></script>
    <script type="text/javascript">
      "use script"; //开发环境建议开启严格模式

      var map;

      function initMap(options) {
        //合并属性参数，可覆盖config.json中的对应配置
        let mapOptions = mars3d.Util.merge(options, {
          scene: {
            center: { lat: 31.834317, lng: 117.2199, alt: 87, heading: 30, pitch: -29 },
            fxaa: true,
          },
        });

        //创建三维地球场景
        map = new mars3d.Map("mars3dContainer", mapOptions);

        let MeshVisualizer = Cesium.MeshVisualizer;
        let Mesh = Cesium.Mesh;
        let MeshMaterial = Cesium.MeshMaterial;
        let FramebufferTexture = Cesium.FramebufferTexture;
        let GeometryUtils = Cesium.GeometryUtils;
        let MeshPhongMaterial = Cesium.MeshPhongMaterial;
        let BasicMeshMaterial = Cesium.BasicMeshMaterial;
        let LOD = Cesium.LOD;

        let center = Cesium.Cartesian3.fromDegrees(117.220206, 31.834866, 50);
        let modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);

        let meshVisualizer = new Cesium.MeshVisualizer({
          modelMatrix: modelMatrix,
          up: { y: 1 },
          referenceAxisParameter: {
            length: 100,
            width: 0.05,
            headLength: 2,
            headWidth: 0.1,
          },
        });
        map.scene.primitives.add(meshVisualizer);

        meshVisualizer.showReference = true; //显示坐标轴

        function createRandomColor() {
          return Cesium.Color.fromRandom({ alpha: 1 }); //fromRgba(Math.floor(Math.random() * (1 << 24)));
        }
        function createMaterial(color) {
          if (typeof color === "string") {
            //
          } else if (Cesium.defined(color)) {
            color = Cesium.Color.fromRgba(color).withAlpha(1);
          } else {
            color = createRandomColor();
          }
          return new MeshPhongMaterial({
            defaultColor: color,
            side: MeshMaterial.Sides.DOUBLE,
            translucent: false,
          });
        }
        let groundMaterial = new MeshPhongMaterial({
          defaultColor: "rgb(255,0,0)",
          side: MeshMaterial.Sides.DOUBLE,
          translucent: false,
        });
        Cesium.Cartesian3.prototype.set = function (x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        };
        Cesium.Cartesian2.prototype.set = function (x, y) {
          this.x = x;
          this.y = y;
        };
        Cesium.Quaternion.prototype.set = function (x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
        };

        Ammo().then(function () {
          // - Global variables -

          // Graphics variables
          let clock = new THREE.Clock();

          let mouseCoords = new THREE.Vector2();
          let raycaster = new THREE.Raycaster();
          let ballMaterial = createMaterial(0x202020);

          // Physics variables
          let gravityConstant = 7.8;
          let collisionConfiguration;
          let dispatcher;
          let broadphase;
          let solver;
          let physicsWorld;
          let margin = 0.05;

          let convexBreaker = new THREE.ConvexObjectBreaker();

          // Rigid bodies include all movable objects
          let rigidBodies = [];

          let pos = new THREE.Vector3();
          let quat = new THREE.Quaternion();
          let transformAux1 = new Ammo.btTransform();
          let tempBtVec3_1 = new Ammo.btVector3(0, 0, 0);

          let time = 0;

          let objectsToRemove = [];
          for (let i = 0; i < 500; i++) {
            objectsToRemove[i] = null;
          }
          let numObjectsToRemove = 0;

          let impactPoint = new THREE.Vector3();
          let impactNormal = new THREE.Vector3();

          function initPhysics() {
            // Physics configuration

            collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
            dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
            broadphase = new Ammo.btDbvtBroadphase();
            solver = new Ammo.btSequentialImpulseConstraintSolver();
            physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
            physicsWorld.setGravity(new Ammo.btVector3(0, -gravityConstant, 0));
          }

          function createObject(mass, halfExtents, pos, quat, material) {
            //y，z调换位置
            let object = new THREE.Mesh(new THREE.BoxGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2), material);
            object.position.copy(pos);
            object.quaternion.copy(quat);
            //object.position.y += 3;
            convexBreaker.prepareBreakableObject(object, mass, new THREE.Vector3(), new THREE.Vector3(), true);

            createDebrisFromBreakableObject(object);
          }

          function createObjects() {
            // Ground
            pos.set(0, -0.5, 0);
            quat.set(0, 0, 0, 1);
            let ground = createParalellepipedWithPhysics(40, 1, 40, 0, pos, quat, createMaterial(0xffffff));

            // Tower 1
            let towerMass = 1000;
            let towerHalfExtents = new THREE.Vector3(2, 5, 2);
            pos.set(-8, 5, 0);
            quat.set(0, 0, 0, 1);
            createObject(towerMass, towerHalfExtents, pos, quat, createMaterial("rgb(247,174,68)"));

            // Tower 2
            pos.set(8, 5, 0);
            quat.set(0, 0, 0, 1);
            createObject(towerMass, towerHalfExtents, pos, quat, createMaterial("rgb(247,174,68)"));

            //Bridge
            let bridgeMass = 100;
            let bridgeHalfExtents = new THREE.Vector3(7, 0.2, 1.5);
            pos.set(0, 10.2, 0);
            quat.set(0, 0, 0, 1);
            createObject(bridgeMass, bridgeHalfExtents, pos, quat, createMaterial("rgb(247,174,68)"));

            // Stones
            let stoneMass = 120;
            let stoneHalfExtents = new THREE.Vector3(1, 2, 0.15);
            let numStones = 8;
            quat.set(0, 0, 0, 1);
            for (let i = 0; i < numStones; i++) {
              pos.set(0, 2, 15 * (0.5 - i / (numStones + 1)));

              createObject(stoneMass, stoneHalfExtents, pos, quat, createMaterial(0xb0b0b0));
            }

            // Mountain
            let mountainMass = 860;
            let mountainHalfExtents = new THREE.Vector3(4, 5, 4);
            pos.set(5, mountainHalfExtents.y * 0.5, -7);
            quat.set(0, 0, 0, 1);
            let mountainPoints = [];
            //y，z调换位置
            mountainPoints.push(new THREE.Vector3(mountainHalfExtents.x, -mountainHalfExtents.y, mountainHalfExtents.z));
            mountainPoints.push(new THREE.Vector3(-mountainHalfExtents.x, -mountainHalfExtents.y, mountainHalfExtents.z));
            mountainPoints.push(new THREE.Vector3(mountainHalfExtents.x, -mountainHalfExtents.y, -mountainHalfExtents.z));
            mountainPoints.push(new THREE.Vector3(-mountainHalfExtents.x, -mountainHalfExtents.y, -mountainHalfExtents.z));
            mountainPoints.push(new THREE.Vector3(0, mountainHalfExtents.y, 0));
            let mountain = new THREE.Mesh(new THREE.ConvexGeometry(mountainPoints), createMaterial("rgb(247,174,68)"));
            mountain.position.copy(pos);
            mountain.quaternion.copy(quat);
            convexBreaker.prepareBreakableObject(mountain, mountainMass, new THREE.Vector3(), new THREE.Vector3(), true);
            createDebrisFromBreakableObject(mountain);
          }

          function createParalellepipedWithPhysics(sx, sy, sz, mass, pos, quat, material) {
            let box = Cesium.BoxGeometry.createGeometry(
              Cesium.BoxGeometry.fromDimensions({
                dimensions: new Cesium.Cartesian3(sx, sy, sz),
                vertexFormat: new Cesium.VertexFormat({
                  position: true,
                  normal: true,
                }),
              })
            );
            let object = new Cesium.Mesh(box, material);
            object.quaternion = new Cesium.Quaternion();
            let shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
            shape.setMargin(margin);

            createRigidBody(object, shape, mass, pos, quat);

            return object;
          }

          function createDebrisFromBreakableObject(object) {
            object.castShadow = true;
            object.receiveShadow = true;

            let shape = createConvexHullPhysicsShape(object.geometry.vertices);
            shape.setMargin(margin);

            let body = createRigidBody(object, shape, object.userData.mass, null, null, object.userData.velocity, object.userData.angularVelocity);

            // Set pointer back to the three object only in the debris objects
            let btVecUserData = new Ammo.btVector3(0, 0, 0);
            btVecUserData.threeObject = object;
            body.setUserPointer(btVecUserData);
          }

          function removeDebris(object) {
            meshVisualizer.remove(object);

            physicsWorld.removeRigidBody(object.userData.physicsBody);
          }

          function createConvexHullPhysicsShape(points) {
            let shape = new Ammo.btConvexHullShape();

            for (let i = 0, il = points.length; i < il; i++) {
              let p = points[i];
              tempBtVec3_1.setValue(p.x, p.y, p.z); //y,z调换位置
              let lastOne = i === il - 1;
              shape.addPoint(tempBtVec3_1, lastOne);
            }

            return shape;
          }

          function createRigidBody(object, physicsShape, mass, pos, quat, vel, angVel) {
            if (pos) {
              object.position.copy(pos);
            } else {
              pos = object.position;
            }
            if (quat) {
              if (object.quaternion) {
                object.quaternion.copy(quat);
              }
            } else {
              quat = object.quaternion;
            }

            let transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
            transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
            let motionState = new Ammo.btDefaultMotionState(transform);

            let localInertia = new Ammo.btVector3(0, 0, 0);
            physicsShape.calculateLocalInertia(mass, localInertia);

            let rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
            let body = new Ammo.btRigidBody(rbInfo);

            body.setFriction(0.5);

            if (vel) {
              body.setLinearVelocity(new Ammo.btVector3(vel.x, vel.y, vel.z));
            }
            if (angVel) {
              body.setAngularVelocity(new Ammo.btVector3(angVel.x, angVel.y, angVel.z));
            }

            object.userData.physicsBody = body;
            object.userData.collided = false;

            meshVisualizer.add(object);

            if (mass > 0) {
              rigidBodies.push(object);

              // Disable deactivation
              body.setActivationState(4);
            }

            physicsWorld.addRigidBody(body);

            return body;
          }

          function updatePhysics(deltaTime) {
            // Step world
            physicsWorld.stepSimulation(deltaTime, 10);

            // Update rigid bodies
            for (let i = 0, il = rigidBodies.length; i < il; i++) {
              let objThree = rigidBodies[i];
              let objPhys = objThree.userData.physicsBody;
              let ms = objPhys.getMotionState();
              if (ms) {
                ms.getWorldTransform(transformAux1);
                let p = transformAux1.getOrigin();
                let q = transformAux1.getRotation();
                objThree.position.set(p.x(), p.y(), p.z());
                if (objThree.quaternion) {
                  objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
                }

                objThree.userData.collided = false;
                objThree.modelMatrixNeedsUpdate = true;
              }
            }

            for (let i = 0, il = dispatcher.getNumManifolds(); i < il; i++) {
              let contactManifold = dispatcher.getManifoldByIndexInternal(i);
              let rb0 = contactManifold.getBody0();
              let rb1 = contactManifold.getBody1();

              let threeObject0 = Ammo.castObject(rb0.getUserPointer(), Ammo.btVector3).threeObject;
              let threeObject1 = Ammo.castObject(rb1.getUserPointer(), Ammo.btVector3).threeObject;

              if (!threeObject0 && !threeObject1) {
                continue;
              }

              let userData0 = threeObject0 ? threeObject0.userData : null;
              let userData1 = threeObject1 ? threeObject1.userData : null;

              let breakable0 = userData0 ? userData0.breakable : false;
              let breakable1 = userData1 ? userData1.breakable : false;

              let collided0 = userData0 ? userData0.collided : false;
              let collided1 = userData1 ? userData1.collided : false;

              if ((!breakable0 && !breakable1) || (collided0 && collided1)) {
                continue;
              }

              let contact = false;
              let maxImpulse = 0;
              for (let j = 0, jl = contactManifold.getNumContacts(); j < jl; j++) {
                let contactPoint = contactManifold.getContactPoint(j);
                if (contactPoint.getDistance() < 0) {
                  contact = true;
                  let impulse = contactPoint.getAppliedImpulse();
                  if (impulse > maxImpulse) {
                    maxImpulse = impulse;
                    let pos = contactPoint.get_m_positionWorldOnB();
                    let normal = contactPoint.get_m_normalWorldOnB();
                    impactPoint.set(pos.x(), pos.y(), pos.z());
                    impactNormal.set(normal.x(), normal.y(), normal.z());
                  }
                  break;
                }
              }

              // If no point has contact, abort
              if (!contact) {
                continue;
              }

              // Subdivision

              let fractureImpulse = 250;

              if (breakable0 && !collided0 && maxImpulse > fractureImpulse) {
                let debris = convexBreaker.subdivideByImpact(threeObject0, impactPoint, impactNormal, 1, 2, 1.5);

                let numObjects = debris.length;
                for (let j = 0; j < numObjects; j++) {
                  createDebrisFromBreakableObject(debris[j]);
                }

                objectsToRemove[numObjectsToRemove++] = threeObject0;
                userData0.collided = true;
              }

              if (breakable1 && !collided1 && maxImpulse > fractureImpulse) {
                let debris = convexBreaker.subdivideByImpact(threeObject1, impactPoint, impactNormal, 1, 2, 1.5);

                let numObjects = debris.length;
                for (let j = 0; j < numObjects; j++) {
                  createDebrisFromBreakableObject(debris[j]);
                }

                objectsToRemove[numObjectsToRemove++] = threeObject1;
                userData1.collided = true;
              }
            }

            for (let i = 0; i < numObjectsToRemove; i++) {
              removeDebris(objectsToRemove[i]);
            }
            numObjectsToRemove = 0;
          }

          let ray = new Cesium.Ray();
          let clickRequest = false;
          let start = false;
          let hasInit = false;
          let startTime = new Date();
          let rayDir = new Cesium.Cartesian3();

          function initInput() {
            let scene = map.scene;
            let handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
            let lastMesh = null;
            handler.setInputAction(function (movement) {
              if (!clickRequest) {
                Cesium.Cartesian2.clone(movement.position, mouseCoords);
                clickRequest = true;
              }
            }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
          }

          function processClick() {
            if (clickRequest) {
              meshVisualizer.getPickRay(mouseCoords, ray);
              if (!ray) {
                clickRequest = false;
                return;
              }
              // Creates a ball
              let ballMass = 35;
              let ballRadius = 0.4;
              let ball = new Cesium.Mesh(
                new Cesium.SphereGeometry({
                  radius: ballRadius,
                  stackPartitions: 14,
                  slicePartitions: 10,
                }),
                ballMaterial
              );

              let ballShape = new Ammo.btSphereShape(ballRadius);
              ballShape.setMargin(margin);

              Cesium.Cartesian3.clone(ray.direction, rayDir);
              Cesium.Cartesian3.subtract(ray.origin, ray.direction, pos);

              quat.set(0, 0, 0, 1);
              let ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);
              //ballBody.setFriction(0.5);

              Cesium.Cartesian3.normalize(rayDir, rayDir);
              Cesium.Cartesian3.multiplyByScalar(rayDir, 50, rayDir);
              //console.log(rayDir);
              ballBody.setLinearVelocity(new Ammo.btVector3(rayDir.x, rayDir.y, rayDir.z));

              clickRequest = false;
            }
          }
          let hs = false;
          function update(frameState) {
            if (hs) {
              return;
            }
            let deltaTime = (new Date() - startTime) / 1000.0;
            updatePhysics(deltaTime);
            processClick();
            startTime = new Date();
            // hs = true;
          }
          setTimeout(function () {
            if (!hasInit) {
              // - Init -

              initPhysics();

              createObjects();

              initInput();

              hasInit = true;
            }
            if (!start) {
              startTime = new Date();
              meshVisualizer.beforeUpdate.addEventListener(update);
              start = true;
            } else {
              meshVisualizer.beforeUpdate.removeEventListener(update);
              start = false;
            }
          }, 1000 * 3);
        });
      }
    </script>
  </body>
</html>
